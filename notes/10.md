# **Polymorphism in Java**

### **What is Polymorphism?**

Polymorphism is one of the core principles of Object-Oriented Programming (OOP). It allows an object to take multiple forms, meaning the **same method name or operator can behave differently based on the object it is acting upon**.

üîπ **Types of Polymorphism in Java:**

1. **Compile-time Polymorphism (Method Overloading)**
2. **Runtime Polymorphism (Method Overriding)**

---

## **1. Compile-time Polymorphism (Method Overloading)**

Compile-time polymorphism occurs when multiple methods in the same class have the **same name but different parameters (method signatures)**. The compiler determines which method to call based on the arguments passed at compile time.

### **Example: Method Overloading**

```java
class MathOperations {
    // Method with two parameters
    int add(int a, int b) {
        return a + b;
    }

    // Overloaded method with three parameters
    int add(int a, int b, int c) {
        return a + b + c;
    }

    // Overloaded method with double parameters
    double add(double a, double b) {
        return a + b;
    }
}

public class OverloadingExample {
    public static void main(String[] args) {
        MathOperations obj = new MathOperations();
        System.out.println("Sum (int, int): " + obj.add(5, 10));
        System.out.println("Sum (int, int, int): " + obj.add(5, 10, 15));
        System.out.println("Sum (double, double): " + obj.add(5.5, 2.2));
    }
}
```

### **Output:**

```
Sum (int, int): 15
Sum (int, int, int): 30
Sum (double, double): 7.7
```

### **Key Takeaways:**

‚úÖ Method Overloading allows multiple methods with the same name but different parameters.  
‚úÖ The correct method is determined at **compile-time** based on the argument list.  
‚úÖ Improves **readability** and **code reusability**.

---

## **2. Runtime Polymorphism (Method Overriding)**

Runtime polymorphism occurs when a subclass provides a **specific implementation** of a method that is already defined in its superclass. The method call is resolved at **runtime**, based on the actual object being referenced.

### **Example: Method Overriding**

```java
class Animal {
    void makeSound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("Cat meows");
    }
}

public class OverridingExample {
    public static void main(String[] args) {
        Animal myAnimal;  // Reference of type Animal

        myAnimal = new Dog();  // Dog object assigned
        myAnimal.makeSound();  // Calls Dog's overridden method

        myAnimal = new Cat();  // Cat object assigned
        myAnimal.makeSound();  // Calls Cat's overridden method
    }
}
```

### **Output:**

```
Dog barks
Cat meows
```

### **Key Takeaways:**

‚úÖ **Method Overriding** allows a subclass to provide a specific implementation of a method in its parent class.  
‚úÖ The method to be executed is determined at **runtime** based on the object being referred to.  
‚úÖ Requires **inheritance** (`extends` keyword).  
‚úÖ Uses the **@Override** annotation to indicate overriding.

---

## **üîç Key Differences Between Overloading & Overriding**

| Feature               | Method Overloading                                           | Method Overriding                                                        |
| --------------------- | ------------------------------------------------------------ | ------------------------------------------------------------------------ |
| **Definition**        | Multiple methods with the same name but different parameters | Subclass provides a new implementation of a method from the parent class |
| **Binding**           | Compile-time (Early Binding)                                 | Runtime (Late Binding)                                                   |
| **Class Involvement** | Same class                                                   | Involves Parent and Child classes                                        |
| **Method Signature**  | Different parameter list                                     | Same method name and parameters                                          |
| **Return Type**       | Can be different                                             | Must be the same (or a subclass type - Covariant return type)            |
| **Keyword Used**      | No special keyword                                           | Uses `@Override` annotation                                              |

---

## **3. Real-world Example of Polymorphism**

### **Example: Bank Interest Calculation**

```java
class Bank {
    double getInterestRate() {
        return 5.0;
    }
}

class SBI extends Bank {
    @Override
    double getInterestRate() {
        return 6.5;
    }
}

class HDFC extends Bank {
    @Override
    double getInterestRate() {
        return 7.0;
    }
}

public class BankExample {
    public static void main(String[] args) {
        Bank bank;  // Reference of Bank

        bank = new SBI();
        System.out.println("SBI Interest Rate: " + bank.getInterestRate() + "%");

        bank = new HDFC();
        System.out.println("HDFC Interest Rate: " + bank.getInterestRate() + "%");
    }
}
```

### **Output:**

```
SBI Interest Rate: 6.5%
HDFC Interest Rate: 7.0%
```

---

---

## **5. Conclusion**

- **Polymorphism** allows the same method to behave differently in different contexts.
- **Method Overloading** (Compile-time polymorphism) happens in the same class and is resolved during compilation.
- **Method Overriding** (Runtime polymorphism) happens in an inheritance scenario and is resolved at runtime.
- **Polymorphism enhances flexibility, maintainability, and scalability** in Java applications.
